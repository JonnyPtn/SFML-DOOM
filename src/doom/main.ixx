//-----------------------------------------------------------------------------
//
// Copyright (C) 1993-1996 by id Software, Inc.
//
// This source is available for distribution and/or modification
// only under the terms of the DOOM Source Code License as
// published by id Software. All rights reserved.
//
// The source is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License
// for more details.
//
//
// DESCRIPTION:
//	DOOM main program (D_DoomMain) and game loop (D_DoomLoop),
//	plus functions to determine game mode (shareware, registered),
//	parse command line parameters, configure game parameters (turbo),
//	and call the startup functions.
//
//-----------------------------------------------------------------------------
module;
#include "g_game.h"
#include "i_video.h"
#include "r_draw.h"
#include "r_main.h"
#include <SFML/Window/Event.hpp>
#include <filesystem>
#include <spdlog/spdlog.h>
export module main;

import engine;
import menu;
import wad;
import engine;
import doom.map;
import net;
import finale;
import sound;
import doom;
import setup;
import wipe;
import intermission;
import video;
import status_bar;
import hud;
import sound;
import app;

export bool nomonsters;  // checkparm of -nomonsters
export bool respawnparm; // checkparm of -respawn
export bool fastparm;    // checkparm of -fast

bool drone;

export bool singletics = false; // debug flag to cancel adaptiveness

bool inhelpscreens;

// -------------------------------------------
// Selected skill type, map etc.
//

// Defaults for menu, methinks.
export skill_t startskill;
export int startepisode;
export int startmap;
export bool autostart;

export bool advancedemo;

char wadfile[1024]; // primary wad file
char mapdir[1024];  // directory of development maps

//
// EVENT HANDLING
//
// Events are asynchronous inputs generally generated by the game user.
// Events can be discarded if no responder claims them
//
std::array<std::unique_ptr<sf::Event>, MAXEVENTS> events;
export int eventhead;
export int eventtail;

//
// D_PostEvent
// Called by the I/O functions when input is detected
//
export void D_PostEvent( const sf::Event &ev )
{
    events[eventhead] = std::make_unique<sf::Event>( ev );
    eventhead = ( ++eventhead ) & ( MAXEVENTS - 1 );
}

//
// D_ProcessEvents
// Send all the events of the given timestamp down the responder chain
//
export void D_ProcessEvents( void )
{
    // IF STORE DEMO, DO NOT ACCEPT INPUT
    if ( ( gamemode == commercial ) && ( wad::index_of( "map01" ) < 0 ) )
        return;

    for ( ; eventtail != eventhead; eventtail = ( ++eventtail ) & ( MAXEVENTS - 1 ) )
    {
        auto &ev = events[eventtail];
        if ( M_Responder( *ev ) )
            continue; // menu ate the event
        G_Responder( *ev );
    }
}

std::string pagename;

//
// D_PageDrawer
//
void D_PageDrawer( void ) { V_DrawPatch( 0, 0, 0, static_cast<patch_t *>( wad::get( pagename ) ) ); }

//
// D_Display
//  draw current display, possibly wiping it from the previous
//

// wipegamestate can be set to -1 to force a wipe on the next draw
export gamestate_t wipegamestate = GS_DEMOSCREEN;
export bool setsizeneeded;

export void D_Display( void )
{
    static bool viewactivestate = false;
    static bool menuactivestate = false;
    static bool inhelpscreensstate = false;
    static bool fullscreen = false;
    static gamestate_t oldgamestate = static_cast<gamestate_t>( -1 );
    static int borderdrawcount;
    int nowtime;
    int tics;
    int wipestart;
    int y;
    bool done;
    bool wipe;
    bool redrawsbar;

    if ( nodrawers )
        return; // for comparative timing / profiling

    redrawsbar = false;

    // change the view size if needed
    if ( setsizeneeded )
    {
        R_ExecuteSetViewSize();
        oldgamestate = static_cast<gamestate_t>( -1 ); // force background redraw
        borderdrawcount = 3;
    }

    // save the current screen if about to wipe
    if ( gamestate != wipegamestate )
    {
        wipe = true;
        wipe_StartScreen( 0, 0, SCREENWIDTH, SCREENHEIGHT );
    }
    else
        wipe = false;

    if ( gamestate == GS_LEVEL && gametic )
        HU_Erase();

    // do buffered drawing
    switch ( gamestate )
    {
    case GS_LEVEL:
        if ( !gametic )
            break;
        if ( automapactive )
            AM_Drawer();
        if ( wipe || ( viewheight != 200 && fullscreen ) )
            redrawsbar = true;
        if ( inhelpscreensstate && !inhelpscreens )
            redrawsbar = true; // just put away the help screen
        ST_Drawer( viewheight == 200, redrawsbar );
        fullscreen = viewheight == 200;
        break;

    case GS_INTERMISSION:
        WI_Drawer();
        break;

    case GS_FINALE:
        F_Drawer();
        break;

    case GS_DEMOSCREEN:
        D_PageDrawer();
        break;
    }

    // draw buffered stuff to screen
    I_UpdateNoBlit();

    // draw the view directly
    if ( gamestate == GS_LEVEL && !automapactive && gametic )
        R_RenderPlayerView( &players[displayplayer] );

    if ( gamestate == GS_LEVEL && gametic )
        HU_Drawer();

    // clean up border stuff
    if ( gamestate != oldgamestate && gamestate != GS_LEVEL )
        I_SetPalette( static_cast<std::byte *>( wad::get( "PLAYPAL" ) ) );

    // see if the border needs to be initially drawn
    if ( gamestate == GS_LEVEL && oldgamestate != GS_LEVEL )
    {
        viewactivestate = false; // view was not active
        R_FillBackScreen();      // draw the pattern into the back screen
    }

    // see if the border needs to be updated to the screen
    if ( gamestate == GS_LEVEL && !automapactive && scaledviewwidth != 320 )
    {
        if ( menuactive || menuactivestate || !viewactivestate )
            borderdrawcount = 3;
        if ( borderdrawcount )
        {
            R_DrawViewBorder(); // erase old menu stuff
            borderdrawcount--;
        }
    }

    menuactivestate = menuactive;
    viewactivestate = viewactive;
    inhelpscreensstate = inhelpscreens;
    oldgamestate = wipegamestate = gamestate;

    // draw pause pic
    if ( paused )
    {
        if ( automapactive )
            y = 4;
        else
            y = viewwindowy + 4;
        V_DrawPatchDirect( viewwindowx + ( scaledviewwidth - 68 ) / 2, y, 0, static_cast<patch_t *>( wad::get( "M_PAUSE" ) ) );
    }

    // menus go directly to the screen
    M_Drawer();  // menu is drawn even on top of everything
    NetUpdate(); // send out any new accumulation

    // normal update
    if ( !wipe )
    {
        I_FinishUpdate(); // page flip or blit buffer
        return;
    }

    // wipe update
    wipe_EndScreen( 0, 0, SCREENWIDTH, SCREENHEIGHT );

    wipestart = get_current_tick() - 1;

    do
    {
        do
        {
            nowtime = get_current_tick();
            tics = nowtime - wipestart;
        } while ( !tics );
        wipestart = nowtime;
        done = wipe_ScreenWipe( wipe_Melt, 0, 0, SCREENWIDTH, SCREENHEIGHT, tics );
        I_UpdateNoBlit();
        M_Drawer();       // menu is drawn even on top of wipes
        I_FinishUpdate(); // page flip or blit buffer
    } while ( !done );
}

//
//  DEMO LOOP
//
int demosequence;
int pagetic;

//
// This cycles through the demo sequences.
// FIXME - version dependend demo numbers?
//
export void D_DoAdvanceDemo( void )
{
    players[consoleplayer].playerstate = PST_LIVE; // not reborn
    advancedemo = false;
    usergame = false; // no save / end game here
    paused = false;
    gameaction = gameaction_t::ga_nothing;

    if ( gamemode == retail )
        demosequence = ( demosequence + 1 ) % 7;
    else
        demosequence = ( demosequence + 1 ) % 6;

    switch ( demosequence )
    {
    case 0:
        if ( gamemode == commercial )
            pagetic = 35 * 11;
        else
            pagetic = 170;
        gamestate = GS_DEMOSCREEN;
        pagename = "TITLEPIC";
        if ( gamemode == commercial )
            S_StartMusic( mus_dm2ttl );
        else
            S_StartMusic( mus_intro );
        break;
    case 1:
        G_DeferedPlayDemo( "demo1" );
        break;
    case 2:
        pagetic = 200;
        gamestate = GS_DEMOSCREEN;
        pagename = "CREDIT";
        break;
    case 3:
        G_DeferedPlayDemo( "demo2" );
        break;
    case 4:
        gamestate = GS_DEMOSCREEN;
        if ( gamemode == commercial )
        {
            pagetic = 35 * 11;
            pagename = "TITLEPIC";
            S_StartMusic( mus_dm2ttl );
        }
        else
        {
            pagetic = 200;

            if ( gamemode == retail )
                pagename = "CREDIT";
            else
                pagename = "HELP2";
        }
        break;
    case 5:
        G_DeferedPlayDemo( "demo3" );
        break;
        // THE DEFINITIVE DOOM Special Edition demo
    case 6:
        G_DeferedPlayDemo( "demo4" );
        break;
    }
}

//
// D-DoomLoop()
//  called by D_DoomMain, never exits.
// Manages timing and IO,
//  calls all ?_Responder, ?_Ticker, and ?_Drawer,
//  calls get_current_tick, I_StartFrame, and I_StartTic
//
export bool demorecording;

//
// D_AdvanceDemo
// Called after each demo or intro demosequence finishes
//
export void D_AdvanceDemo( void ) { advancedemo = true; }

//
// D_PageTicker
// Handles timing for warped projection
//
export void D_PageTicker( void )
{
    if ( --pagetic < 0 )
        D_AdvanceDemo();
}

//
// D_StartTitle
//
export void D_StartTitle( void )
{
    gameaction = gameaction_t::ga_nothing;
    demosequence = -1;
    D_AdvanceDemo();
}

export fixed_t forwardmove[2] = { 0x19, 0x32 };
export fixed_t sidemove[2] = { 0x18, 0x28 };